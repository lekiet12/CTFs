
#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <xmmintrin.h>
#include <math.h>
#include <stdint.h>
#include "sha256.h"
unsigned char s_box[256]={0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 
  0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 
  0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 
  0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 
  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 
  0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 
  0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 
  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 
  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 
  0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 
  0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 
  0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 
  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 
  0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 
  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 
  0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 
  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 
  0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 
  0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 
  0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 
  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 
  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 
  0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 
  0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 
  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 
  0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};
unsigned char s_box_custom[256]={0x2,0x1b,0x5a,0x3d,0x23,0x58,0xdf,0x5e,0xa3,0x10,0x16,0x21,0xa,0x3a,0xca,0x6a,0x83,0xe8,0x2b,0xc6,0x95,0xa0,0xba,0xc3,0x29,0x25,0x1a,0x3c,0xf5,0x24,0xc0,0x33,0x42,0xff,0x35,0x49,0xeb,0x96,0x2c,0xe2,0x7c,0x82,0xb4,0x6,0xa1,0xe1,0x72,0x2d,0x61,0x4a,0xf8,0x9b,0xdc,0xfa,0x62,0xa2,0x53,0xb0,0x4d,0xec,0x12,0x57,0x9d,0xce,0xda,0xdd,0x52,0xc1,0xc9,0xf7,0xe3,0x5d,0xbb,0x1,0x81,0xf9,0x45,0xc,0xc8,0xa9,0x5b,0xe7,0xef,0xf0,0xa7,0x80,0x54,0xde,0xb7,0x74,0xb6,0x94,0xab,0xc2,0x50,0x6b,0xee,0x56,0x93,0xc5,0x6c,0x76,0x4c,0xa6,0x32,0x7a,0x3b,0x4e,0xe5,0x14,0x27,0x4b,0x64,0x8a,0xaf,0xfd,0xf2,0xd6,0x7f,0xd8,0xcb,0x48,0x87,0x8f,0xed,0x63,0x11,0x3f,0xfe,0xd7,0xc7,0xf1,0x8,0x4,0xb3,0xf4,0xdb,0xf6,0x1e,0x67,0x7d,0x7e,0x86,0x78,0x6f,0x84,0xd4,0xaa,0x6e,0x5,0x41,0xd2,0x2a,0x2f,0x0,0x85,0x55,0xd0,0x38,0x8d,0xb9,0x47,0xb2,0x31,0xb5,0x70,0x9f,0x7,0xc4,0xe0,0x22,0x15,0x60,0xd1,0x89,0x7b,0xd,0x44,0xbf,0x73,0x59,0xa8,0x4f,0x66,0x65,0xfb,0x9c,0x51,0xcf,0x1c,0x97,0x28,0x2e,0x39,0x3e,0x20,0xad,0x79,0x46,0xd9,0xfc,0x30,0xb,0xf3,0x9e,0xb1,0x6d,0xea,0x43,0x1f,0xd3,0xbd,0x1d,0x9a,0xe6,0x8c,0x92,0x8e,0xd5,0x91,0x98,0xae,0xf,0x77,0xbe,0x19,0x5c,0x88,0x40,0x9,0x37,0x68,0xcc,0xe4,0x5f,0x8b,0x99,0x34,0xac,0xbc,0x13,0x26,0x69,0xa5,0xb8,0x36,0xe,0x71,0x3,0x90,0xcd,0x17,0xa4,0x18,0xe9,0x75};
#define SBOX_SIZE 256


void rc4_crypt(unsigned char data[], unsigned int data_length, unsigned char key[], unsigned int key_length) {
    unsigned char state[256]; 
    unsigned int i, j = 0, k = 0;

    for (i = 0; i < 256; ++i) {
        state[i] = i;  
    }
    for (i = 0; i < 256; ++i) {
        j = (j + state[i] + key[i & 31]) % 256; 
        unsigned char temp = state[i];
        state[i] = state[j];
        state[j] = temp;
    }
	
    i = 0;
    j = 0;
    for (unsigned int idx = 0; idx < data_length; ++idx) {
        i = (i + 1) % 256;
        j = (j + state[i]) % 256;
        
        unsigned char temp = state[i];
        state[i] = state[j];
        state[j] = temp;
        
        unsigned char xor_value = state[(state[i] + state[j]) % 256];
        data[idx] ^= xor_value;
	}
}
int index_of(unsigned char arr[], unsigned char value) {
    for (int i = 0; i < 256; i++) {
        if (arr[i] == value) {
            return i;
        }
    }
    return -1;
}
void sha256_test(BYTE text1[])
{
	BYTE buf[SHA256_BLOCK_SIZE];
	SHA256_CTX ctx;
	int idx;
	int pass = 1;
	unsigned char key[SHA256_BLOCK_SIZE];
    memset(key,0,sizeof(key));
	int index[32]={3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12, 19, 18, 17, 16, 23, 22, 21, 20, 27, 26, 25, 24, 31, 30, 29, 28};
	sha256_init(&ctx);
	sha256_update(&ctx, text1, 8);
	sha256_final(&ctx, buf);
	for (int i = 0; i < 32; ++i ){
		key[i]=buf[index[i]];
	}
  
	unsigned char cipher[]={0x57,0x4a,0x8b,0x50,0xa9,0x1d,0x91,0xb8,0x0e,0x32,0xc3,0xcc,0x94,0x3f,0xc5,0x28,0xfa,0xd9,0x57,0x79,0xa0,0xbf,0x91,0xb0,0x4c,0x91,0xfd,0xa4,0x69,0xf2,0x56,0xd6,0x57,0xe2,0x1e,0xf3,0xe6,0x52,0x01,0xf4,0x0d};
    rc4_crypt(cipher,41,key,32);
    unsigned char plaintext[41]={0};
    plaintext[40] = index_of(s_box, cipher[40]);

    for (int i = 39; i >= 0; i--) {
        int index_custom = index_of(s_box_custom, cipher[i]);
        plaintext[i] = index_of(s_box, index_custom) ^ plaintext[i + 1];
        if(plaintext[i]>126){
            return ;
        }
    }
    printf("Plaintext: ");
    for (int i = 0; i < 41; i++) {
        printf("%c", plaintext[i]);
    }
    printf("\n");
}

__m128 function(int base, int a2) {
    int v2 = 0; // Đếm số vòng lặp
    __int128 v3 = 0; // Kết quả trả về
    double v4 = 0.0; // Tích lũy giá trị
    int v7 = base; // Giá trị cơ sở
    double v8; // Biến tạm
    double v9; // Biến tạm
    __int64 v10; // Biến tạm cho vòng lặp
    int v11; // Biến tạm
    __int128 v12; // Biến tạm
    int v13; // Biến tạm

    if (a2 >= 0) {
        do {
            v8 = 1.0;
            v9 = (double)v7;
            if (a2 - v2 > 0) {
                v10 = (unsigned int)(a2 - v2);
                do {
                    v8 = fmod(v8 * 16.0, v9);
                    --v10;
                } while (v10);
            }
            ++v2;
            v7 += 8;
            v4 = fmod(v8 / v9 + v4, 1.0);
        } while (v2 <= a2);
    }

    v11 = base + 8 * (a2 + 1);
    *((__int64 *)&v12 + 1) = 0LL;
    *(double *)&v12 = pow(16.0, -1.0) / (double)v11 + 0.0;
    if (*(double *)&v12 != 0.0) {
        v13 = -1;
        do {
            --v13;
            v3 = v12;
            v11 += 8;
            *(double *)&v12 = *(double *)&v12 + pow(16.0, (double)v13) / (double)v11;
        } while (*(double *)&v3 != *(double *)&v12);
    }
    *(double *)&v3 = *(double *)&v3 + v4;
    return (__m128)v3;
}

void get_key(int a2, unsigned char key[]){
    __m128 result1 = function(4, a2);

    double* v8 = (double*)&result1; // Chuyển đổi kết quả sang double
    // printf("Result for base 4: %llx \n", *(unsigned long long*)&v8[0]); // In ra kết quả


    __m128 result2 = function(1, a2);
    double* v9 = (double*)&result2;
    // printf("Result for base 1: %llx \n", *(unsigned long long*)&v9[0]); // In ra kết quả


    __m128 result3 = function(5, a2);
    double* v10 = (double*)&result3;
    // printf("Result for base 5: %llx \n", *(unsigned long long*)&v10[0]);

    double computedValue = (v9[0]*4.0);
    computedValue -=(v8[0]+v8[0]);
    computedValue -= (v10[0]);
    __m128 result4 = function(6, a2);

    double* v11 = (double*)&result4;

    double v12 = fmod(computedValue - v11[0], 1.0);
    double v13 = pow(16.0, 14.0);
    double v14 = floor(v12 * v13);
    

    int64_t intValue = (int64_t)v14; 

    for(int i=0;i<7;i++){
        key[i]=(intValue >> (8*i))&0xff;
    }
}

int main()
{
    printf("start\n");
    unsigned char key[8];
    key[7]=0x80;
    for(unsigned int seed = 0; seed < UINT32_MAX;seed++){
        get_key(seed,key);
        sha256_test(key);
        if (seed % 0x1000 == 0){
            printf("AT %x\n",seed);
        }
    }
	return(0);
}

// Honor_is_earned_through_actions_not_words